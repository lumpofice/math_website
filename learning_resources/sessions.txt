For each user, Flask creates a dictionary called session, storing key value pairs specific to the user through a cookie that has been cryptographically signed using the configured SECRET_KEY in our application's configuration file. This is important for the user experience, making the transition from one point to another in our application smoother. POST requests have access to the data a user enters for the duration of the request, but session has access to the data from request to request. So, after we implement a POST/Redirect/GET pattern---this is a pattern used to obviate the undesirable outcome of form data being submitted multiple times as the user refreshes their browser---in our application, the session dictionary is what must be accessed by the application to retrieve data previously entered by the user. Below, (1) displays the code for the application and i) how the view function uses the session object to store data entered by the user and ii) how the view function uses the redirect method to avoid the undesirable outcome of multiple submissions of user data:

(1)-----------------------------------------------------------------
app = Flask('hello')
app.config['SECRET_KEY'] = 'give it a try'
bootstrap = Bootstrap(app)
moment = Moment(app)

@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
def index():
    form = NameForm()
    if form.validate_on_submit():
        session['name'] = form.flask_name.data
        return redirect(url_for('index'))
    return render_template('index.html',
        current_time=datetime.utcnow(),
        form=form, jinja_name=session.get('name'))

@app.route('/user/<flask_name>')
def user(flask_name):
    return render_template('user.html', jinja_name=flask_name)

@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

class NameForm(FlaskForm):
    flask_name = StringField('What is your name?', 
        validators=[DataRequired()])
    submit = SubmitField('Apologize')

if __name__ == '__main__':
    app.run(debug=True)
--------------------------------------------------------------------

With the use of the flash function from Flask, we can analyze what is happening with our session object. Notice (2) and (3) below. In (2), we change the index view function to handle the additional flash functionality, while in (3), we modify the base.html file to carry out a for loop control structure on the flashed messages generated by the application. Note that, between (1) and (2), the 'name' key for our session object has changed to 'flask_name', while the attribute flask_name has remained unchanged.

(2)-----------------------------------------------------------------
app = Flask('hello')
app.config['SECRET_KEY'] = 'give it a try'
bootstrap = Bootstrap(app)
moment = Moment(app)

@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
def index():
    form = NameForm()
    if form.validate_on_submit():
        old_name = session.get('flask_name')
        if old_name is not None and old_name !=\ 
            form.flask_name.data:
            flash('You have multiple names?')
        session['flask_name'] = form.flask_name.data
        form.flask_name.data = ''
        return redirect(url_for('index'))
    return render_template('index.html',
        current_time=datetime.utcnow(),
        form=form, jinja_name=session.get('flask_name'))

@app.route('/user/<flask_name>')
def user(flask_name):
    return render_template('user.html', jinja_name=flask_name)

@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

class NameForm(FlaskForm):
    flask_name = StringField('What is your name?', 
        validators=[DataRequired()])
    submit = SubmitField('Apologize')

if __name__ == '__main__':
    app.run(debug=True)
--------------------------------------------------------------------

(3)-----------------------------------------------------------------
{% extends 'bootstrap/base.html' %}

{% block title %}{% endblock %}

{% block navbar %}
# ...
{% endblock %}

{% block content %}
<div class='container'>
    {% for message in get_flashed_messages() %}
    <div class='alert alert-warning'>
        <button type='button' class='close' data-dismiss='alert'>
        &times;</button>
        {{ message }}
    </div>
    {% endfor %}

    {% block page_content %}{% endblock %}
</div>

{% block scripts %}
# ...
{% endblock %}
--------------------------------------------------------------------

We modify the base template so that the flashed message shows up on any page to which our user is redirected. In (2), the get method for our session object grabs the current value of the session 'flask_name' key, while the session['flask_name'] sets the value of the session 'flask_name' key to the data string entered by the user.