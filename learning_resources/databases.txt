When setting up our database, we use the Flask wrapper for SQLAlchemy, Flask-SQLAlchemy, which is an object-relational mapper with optional access to the low-level SQL code. The database we will use is SQLite. The columns for our tables will correspond with the Python attributes used in the setup definition, which includes the datatype and whether or not the attribute is to serve as a primary/foreign key; whether or not the attribute will serve as a unique value; whether or not we are to assign to it an index; and whether or not it defines a X-to-Y relationship.

(1)-----------------------------------------------------------------
# ...
from flask_sqlalchemy import SQLAlchemy
import os

basedir = os.path.abspath(os.path.dirname(__file__))

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] =\
    'sqlite://' + os.path.join(basedir, 'data.sqlite')
app.config['SQLALCHEMY_COMMIT_ON_TEARDOWN'] = True
app.config['SECRET_KEY'] = 'give it a try'
bootstrap = Bootstrap(app)
moment = Moment(app)
db = SQLAlchemy(app)

# ...

class Role(db.Model):
    __tablename__ = 'roles'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(64), unique=True)
    users = db.relationship('User', backref='role')
    
    def __repr__(self):
        return '<Role %r>' % self.name
    
class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, index=True)
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    
    def __repr__(self):
        return '<User %r>' % self.username

# ...
--------------------------------------------------------------------

The Role model contains a users attribute, which defines a one-to-many relationship with the User model via the role attribute. The role attribute, which is the value of the backref configuration option in the relationship definition, users, contained within the Role model, serves in place of the foreign key, roles_id, contained within the User model. This backref configuration option exists as a precaution against any ambiguity the relationship definition might face while attempting to locate the relationship's foreign key in the User model.

When endeavoring to create a database through the model classes, the following context should be pushed in the terminal python shell or in the terminal flask shell via the flask shell subcommand:

(2)-----------------------------------------------------------------
>>>from hrllo import app
>>>from hrllo import db
>>>app_ctx = app.app_context()
>>>app_ctx.push()
>>>db.create_all()
--------------------------------------------------------------------

When considering the subcommands. within the terminal, available through the flask command, flask db is unavailable so long as the migrate object is not present within the application.
