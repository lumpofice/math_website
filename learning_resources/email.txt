We can set up an email account to receive emails within our application. We need the flask-mail extension and we need the environment variables. After installing the flask-mail extension through pip, we import he Mail class into our application, passing our application to it as an argument. Then we state our non-private environment variables and the get methods for private environment variables within the script, (1), before heading over to the terminal bash window to set our private environment variables. Finally, we open the flask shell, (2), to test the process.

(1)-----------------------------------------------------------------
# ...
from flask_mail import Mail

# ...
app.config['SECRET_KEY'] = 'give it a try'
app.config['MAIL_SERVER'] = 'smtp.googlemail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')
app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')
bootstrap = Bootstrap(app)
moment = Moment(app)
db = SQLAlchemy(app)
migrate = Migrate(app, db)
mail = Mail(app)

# ...
--------------------------------------------------------------------

(2)-----------------------------------------------------------------
>>>export FLASK_APP=hrllo.py
>>>export MAIL_USERNAME=emailhandle@gmail.com
>>>export MAIL_PASSWORD=emailpassword
>>>flask shell
>>>from flask_mail import Message
>>>from hrllo import mail
>>>msg = Message('test subject', sender='emailhandle@gmail.com',
                 recipients=['emailhandle@gmail.com'])
>>>msg.body = 'test body'
>>>msg.html = '<b>BOLD WORDS</b> but can you back them up?'
>>>with app.app_context():
...    mail.send(msg)
--------------------------------------------------------------------

First, msg.body does not appear in the email successfully sent. In fact, leaving it out altogether changes nothing about the successful sending of the email. Second, the send method uses the current_app object, requiring us to activate an application context.